Object subclass: #CreakoutBallModel	instanceVariableNames: 'position direction'	classVariableNames: ''	poolDictionaries: ''	category: 'Creakout'!!CreakoutBallModel commentStamp: 'StevenRemot 4/6/2017 17:10' prior: 0!I represent a ball in the creakout game!!CreakoutBallModel methodsFor: 'initialization' stamp: 'StevenRemot 4/6/2017 17:10'!initialize	position := 0@0.	direction := 0@0.! !!CreakoutBallModel methodsFor: 'testing' stamp: 'StevenRemot 4/6/2017 17:29'!isInRect: aRect	| halfInnerRect innerRect |	halfInnerRect := (self radius)@(self radius).	innerRect := (self position - halfInnerRect) rectangle: (self position + halfInnerRect).	^aRect containsRect: innerRect.! !!CreakoutBallModel methodsFor: 'updating' stamp: 'StevenRemot 4/6/2017 17:15'!update: milliseconds	position := position + (direction * self speed * milliseconds / 1000.0)! !!CreakoutBallModel methodsFor: 'accessing' stamp: 'StevenRemot 4/6/2017 17:11'!position	^position! !!CreakoutBallModel methodsFor: 'accessing' stamp: 'StevenRemot 4/8/2017 15:04'!speed	"pixels / second"	^70! !!CreakoutBallModel methodsFor: 'accessing' stamp: 'StevenRemot 4/6/2017 17:11'!direction	^direction! !!CreakoutBallModel methodsFor: 'accessing' stamp: 'StevenRemot 4/8/2017 14:25'!radius	^1.5! !!CreakoutBallModel methodsFor: 'accessing' stamp: 'StevenRemot 4/6/2017 17:11'!position: aPoint	position := aPoint! !!CreakoutBallModel methodsFor: 'accessing' stamp: 'StevenRemot 4/6/2017 17:14'!direction: aVector	| radius |	radius := aVector r.		radius = 0		ifTrue: [ direction := aVector ]		ifFalse: [ direction := aVector / radius ]! !Object subclass: #CreakoutBrickModel	instanceVariableNames: 'radius thickness origin angle width color bounceFactor'	classVariableNames: ''	poolDictionaries: ''	category: 'Creakout'!!CreakoutBrickModel commentStamp: 'StevenRemot 4/7/2017 19:06' prior: 0!I represent a general purpose brick in the breakout.!!CreakoutBrickModel methodsFor: 'private - collision' stamp: 'StevenRemot 4/8/2017 13:50'!innerPartCollidesWith: aBall vector: aBallVector	"Assume the ball is in the pad orbit, and check whether the ball collides with the ""inner"" part	of the pad (inner part = pad without the circles)"	^ (self leftVector normal dotProduct: aBallVector) > 0		and: [ (self rightVector normal dotProduct: aBallVector) < 0 ]! !!CreakoutBrickModel methodsFor: 'private - collision' stamp: 'StevenRemot 4/8/2017 14:42'!computeOuterBounceAngleBetween: aCenter and: aBall vector: aBallVector	"Assume there is a collision with the ball in the outer part, and compute the new direction of the ball	after bounce"	^ (aBallVector - aCenter) normalized! !!CreakoutBrickModel methodsFor: 'private - collision' stamp: 'StevenRemot 4/8/2017 13:51'!orbitCollidesWith: aBall vector: aBallVector	"Check is the ball is in the pad orbit, and in a direction the allows collision"	| ballRadius isNavigatingInside offset |	ballRadius := aBallVector r.	isNavigatingInside := (aBallVector dotProduct: aBall direction) < 0.		(((ballRadius < radius) and: isNavigatingInside)		or: [ (ballRadius > radius) and: isNavigatingInside not ])		ifTrue: [ ^ false ].			offset := aBall radius + (self thickness / 2.0).		^((ballRadius - radius)		between: offset negated		and: offset).	! !!CreakoutBrickModel methodsFor: 'private - collision' stamp: 'StevenRemot 5/1/2017 16:39'!computeInnerBounceAngleWith: aBall vector: aBallVector	"Assume there is a collision with the ball in the inner part, and compute the new direction of the ball	after bounce"	| bounceAngle bounceOffset |	bounceOffset := (aBallVector angle - angle degreesToRadians).			bounceAngle := aBallVector angle - (bounceOffset * bounceFactor).	(aBallVector dotProduct: aBall direction) > 0		ifTrue: [ bounceAngle := bounceAngle + CreakoutMath pi ].	^ bounceAngle cos @ bounceAngle sin! !!CreakoutBrickModel methodsFor: 'accessing' stamp: 'StevenRemot 4/7/2017 19:08'!thickness: aNumber	thickness := aNumber! !!CreakoutBrickModel methodsFor: 'accessing' stamp: 'StevenRemot 4/7/2017 19:08'!color: aColor	color := aColor! !!CreakoutBrickModel methodsFor: 'accessing' stamp: 'StevenRemot 4/7/2017 19:14'!origin: aPoint	origin := aPoint.! !!CreakoutBrickModel methodsFor: 'accessing' stamp: 'StevenRemot 4/7/2017 19:09'!angle: aNumber	angle := aNumber! !!CreakoutBrickModel methodsFor: 'accessing'!leftVector	^ Point r: 1 degrees: self leftAngle! !!CreakoutBrickModel methodsFor: 'accessing' stamp: 'StevenRemot 4/7/2017 19:14'!origin	^origin! !!CreakoutBrickModel methodsFor: 'accessing' stamp: 'StevenRemot 4/7/2017 19:08'!width	^width! !!CreakoutBrickModel methodsFor: 'accessing' stamp: 'StevenRemot 4/7/2017 19:08'!thickness	^thickness! !!CreakoutBrickModel methodsFor: 'accessing' stamp: 'StevenRemot 4/7/2017 19:08'!width: aNumber	width := aNumber! !!CreakoutBrickModel methodsFor: 'accessing' stamp: 'StevenRemot 4/7/2017 19:08'!angle	^angle! !!CreakoutBrickModel methodsFor: 'accessing' stamp: 'StevenRemot 4/7/2017 19:18'!bounceFactor	^bounceFactor! !!CreakoutBrickModel methodsFor: 'accessing' stamp: 'StevenRemot 4/7/2017 19:18'!bounceFactor: aNumber	bounceFactor := aNumber! !!CreakoutBrickModel methodsFor: 'accessing' stamp: 'StevenRemot 4/7/2017 19:07'!radius	^radius! !!CreakoutBrickModel methodsFor: 'accessing' stamp: 'StevenRemot 4/7/2017 19:08'!radius: aNumber	radius := aNumber! !!CreakoutBrickModel methodsFor: 'accessing'!rightAngle	^ angle + (self width / 2.0)! !!CreakoutBrickModel methodsFor: 'accessing' stamp: 'StevenRemot 4/7/2017 19:08'!color	^color! !!CreakoutBrickModel methodsFor: 'accessing'!leftAngle	^ angle - (self width / 2.0)! !!CreakoutBrickModel methodsFor: 'accessing' stamp: 'StevenRemot 4/7/2017 19:15'!rightVector	^Point r: 1 degrees: self rightAngle! !!CreakoutBrickModel methodsFor: 'collision' stamp: 'StevenRemot 4/8/2017 14:44'!collisionVectorWith: aBall	| ballVector leftVector rightVector offset leftCenter rightCenter |	ballVector := aBall position - origin.		(self orbitCollidesWith: aBall vector: ballVector)		ifFalse: [ ^ nil ].			leftVector := self leftVector.	rightVector := self rightVector.	offset := aBall radius + (thickness / 2.0).		(self innerPartCollidesWith: aBall vector: ballVector)		ifTrue: [ ^ self computeInnerBounceAngleWith: aBall vector: ballVector ]		ifFalse: [ leftCenter := leftVector * radius.			rightCenter := rightVector * radius.			((leftCenter - ballVector) r <= offset)				ifTrue: [ ^ self computeOuterBounceAngleBetween: leftCenter and: aBall vector: ballVector ].			((rightCenter - ballVector) r <= offset)				ifTrue: [ ^ self computeOuterBounceAngleBetween: rightCenter and: aBall vector: ballVector ]].				^ nil! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CreakoutBrickModel class	instanceVariableNames: ''!!CreakoutBrickModel class methodsFor: 'instance creation' stamp: 'StevenRemot 4/8/2017 13:17'!radius: aRadius thickness: aThickness origin: aPoint angle: anAngle width: aWidth color: aColor bounceFactor: aFactor	^ self new		radius: aRadius;		thickness: aThickness;		origin: aPoint;		angle: anAngle;		width: aWidth;		color: aColor;		bounceFactor: aFactor! !Object subclass: #CreakoutModel	instanceVariableNames: 'pad ball phase bricks currentLevel lives'	classVariableNames: ''	poolDictionaries: ''	category: 'Creakout'!!CreakoutModel commentStamp: 'StevenRemot 4/6/2017 14:01' prior: 0!I gather all the data of a Creakout game.!!CreakoutModel methodsFor: 'game phases' stamp: 'StevenRemot 4/7/2017 12:50'!startAiming	phase := #aiming.	ball direction: 0@0.! !!CreakoutModel methodsFor: 'game phases' stamp: 'StevenRemot 4/7/2017 12:53'!shoot	phase = #aiming		ifFalse: [ ^ self ].			phase := #ballMoving.	ball direction: pad aimingDirection! !!CreakoutModel methodsFor: 'game phases' stamp: 'StevenRemot 4/8/2017 15:15'!handleBrickDead: aBrick	bricks remove: aBrick;		ifEmpty: [ self startNewLevel ]! !!CreakoutModel methodsFor: 'game phases'!lose	phase := #defeat! !!CreakoutModel methodsFor: 'game phases' stamp: 'StevenRemot 4/8/2017 15:18'!startNewLevel	currentLevel := currentLevel + 1.	currentLevel > self levels size		ifTrue: [ phase := #victory.			^ self ].	self perform: (self levels at: currentLevel).	self startAiming! !!CreakoutModel methodsFor: 'levels' stamp: 'StevenRemot 4/8/2017 15:11'!levels	^ #(level1 level2)! !!CreakoutModel methodsFor: 'levels' stamp: 'StevenRemot 4/8/2017 15:03'!level2	bricks removeAll.	self		addBrickRadius: 25.0 angle: 0 life: 4;		addBrickRadius: 25.0 angle: 120 life: 4;		addBrickRadius: 25.0 angle: 240 life: 4;		addBrickRadius: 10.0 angle: 0 life: 6;		addBrickRadius: 10.0 angle: 180 life: 6! !!CreakoutModel methodsFor: 'levels' stamp: 'StevenRemot 4/8/2017 14:59'!level1	bricks removeAll.	self		addBrickRadius: 20.0 angle: 0 life: 2;		addBrickRadius: 20.0 angle: 90 life: 2;		addBrickRadius: 20.0 angle: 180 life: 2;		addBrickRadius: 20.0 angle: 270 life: 2! !!CreakoutModel methodsFor: 'iterating' stamp: 'StevenRemot 4/8/2017 13:21'!doBricks: aBlock	bricks do: aBlock.! !!CreakoutModel methodsFor: 'level creation' stamp: 'StevenRemot 4/8/2017 15:15'!addBrickRadius: aRadius angle: anAngle life: aLife	bricks		add:			(CreakoutTargetBrickModel				radius: aRadius				origin: self boardCenter				angle: anAngle				life: aLife				onDead: [ :brick | self handleBrickDead: brick ])! !!CreakoutModel methodsFor: 'accessing' stamp: 'StevenRemot 4/8/2017 15:17'!ifVictory: aBlock	(phase = #victory) ifTrue: aBlock! !!CreakoutModel methodsFor: 'accessing' stamp: 'StevenRemot 4/6/2017 13:58'!pad	^pad! !!CreakoutModel methodsFor: 'accessing' stamp: 'StevenRemot 4/8/2017 15:31'!ifEnd: aBlock	self		ifDefeat: aBlock;		ifVictory: aBlock.! !!CreakoutModel methodsFor: 'accessing' stamp: 'StevenRemot 4/8/2017 13:20'!boardCenter	^(self boardSize / 2.0)@(self boardSize / 2.0)! !!CreakoutModel methodsFor: 'accessing' stamp: 'StevenRemot 4/6/2017 17:16'!ball	^ball! !!CreakoutModel methodsFor: 'accessing' stamp: 'StevenRemot 4/8/2017 15:30'!ifDefeat: aBlock	(phase = #defeat) ifTrue: aBlock! !!CreakoutModel methodsFor: 'accessing' stamp: 'StevenRemot 4/6/2017 17:17'!boardSize	^100! !!CreakoutModel methodsFor: 'updating' stamp: 'StevenRemot 5/1/2017 16:45'!handleBallCollideWithBricks	| bounceVector |	self		doBricks: [ :brick | 			bounceVector := brick collisionVectorWith: ball.			bounceVector				ifNotNil: [ ball						direction: ball direction - (bounceVector * 2 * (ball direction dotProduct: bounceVector)).					brick hit.					^ self ] ]! !!CreakoutModel methodsFor: 'updating' stamp: 'StevenRemot 4/8/2017 13:30'!handleBallCollidesWithPadAnd: aBlock	| bounceVector |	bounceVector := pad collidesWithBall: ball.	bounceVector		ifNotNil: [ ball direction: bounceVector.			^ self ].	aBlock value! !!CreakoutModel methodsFor: 'updating' stamp: 'StevenRemot 4/8/2017 15:31'!handleBallOutAnd: aBlock	(ball isInRect: ((0@0) extent: (self boardSize)@(self boardSize)))				ifTrue: aBlock				ifFalse: [ 					lives := lives - 1.					(lives = 0)						ifTrue: [ self lose ]						ifFalse: [ self startAiming ]].! !!CreakoutModel methodsFor: 'updating' stamp: 'StevenRemot 4/8/2017 15:31'!update: milliseconds	self ifEnd: [ ^ self ].	pad update: milliseconds.	phase = #aiming		ifTrue: [ ball position: (pad aimingPositionFor: ball) ]		ifFalse: [ ball update: milliseconds.			self				handleBallOutAnd: [ self handleBallCollidesWithPadAnd: [ self handleBallCollideWithBricks ] ] ].	self doBricks: [ :brick | brick update: milliseconds ]	! !!CreakoutModel methodsFor: 'initialization' stamp: 'StevenRemot 4/8/2017 15:29'!initialize	pad := CreakoutPadModel center: self boardCenter.	ball := CreakoutBallModel new.	bricks := Set new.	lives := 3.	currentLevel := 0.	self startNewLevel.! !!CreakoutModel methodsFor: 'initialization'!restart	self initialize! !Object subclass: #CreakoutPadModel	instanceVariableNames: 'pads rotationDirection center rotationSpeed'	classVariableNames: ''	poolDictionaries: ''	category: 'Creakout'!!CreakoutPadModel commentStamp: 'StevenRemot 4/6/2017 13:54' prior: 0!I am the model of a pad!!CreakoutPadModel methodsFor: 'iterating' stamp: 'StevenRemot 4/7/2017 19:33'!doPads: aBlock	pads do: aBlock! !!CreakoutPadModel methodsFor: 'accessing' stamp: 'StevenRemot 4/7/2017 19:30'!rotation: aNumber	1 to: self numberOfPads do: [ :padNumber |		(pads at: padNumber) angle: aNumber + ((padNumber - 1) * self padGap) ]! !!CreakoutPadModel methodsFor: 'accessing' stamp: 'StevenRemot 4/6/2017 17:55'!leftAngleFor: aPad	^(self centerAngleFor: aPad) - (self padWidth / 2.0)! !!CreakoutPadModel methodsFor: 'accessing' stamp: 'StevenRemot 4/6/2017 13:56'!padWidth	^20.0! !!CreakoutPadModel methodsFor: 'accessing'!padColor	^ Color h: 0 s: 0.9 l: 0.6! !!CreakoutPadModel methodsFor: 'accessing' stamp: 'StevenRemot 4/16/2017 13:55'!rotationDirection: aDirection	rotationDirection := aDirection min: 1 max: -1! !!CreakoutPadModel methodsFor: 'accessing' stamp: 'StevenRemot 4/6/2017 17:54'!padGap	^360.0 / self numberOfPads ! !!CreakoutPadModel methodsFor: 'accessing'!aimingDirection	^ Point r: 1 degrees: (self centerAngleFor: 1) + 180.0! !!CreakoutPadModel methodsFor: 'accessing' stamp: 'StevenRemot 4/7/2017 19:39'!center: aPoint	center := aPoint! !!CreakoutPadModel methodsFor: 'accessing' stamp: 'StevenRemot 4/6/2017 15:41'!rotationDirection	^rotationDirection! !!CreakoutPadModel methodsFor: 'accessing' stamp: 'StevenRemot 4/6/2017 15:29'!maxRotationSpeed	"degrees / second"	^360! !!CreakoutPadModel methodsFor: 'accessing' stamp: 'StevenRemot 4/7/2017 19:49'!centerAngleFor: aPad	^ (pads at: aPad) angle! !!CreakoutPadModel methodsFor: 'accessing' stamp: 'StevenRemot 4/6/2017 13:56'!numberOfPads	^3! !!CreakoutPadModel methodsFor: 'accessing' stamp: 'StevenRemot 4/7/2017 19:31'!rotate: aNumber	pads do: [  :pad | pad angle: pad angle + aNumber ]! !!CreakoutPadModel methodsFor: 'accessing' stamp: 'StevenRemot 4/7/2017 19:39'!center	^center! !!CreakoutPadModel methodsFor: 'accessing' stamp: 'StevenRemot 4/6/2017 18:20'!rightVectorFor: aPad	| angle |	angle := (self rightAngleFor: aPad) degreesToRadians.	^(angle cos)@(angle sin)! !!CreakoutPadModel methodsFor: 'accessing' stamp: 'StevenRemot 4/8/2017 14:25'!thickness	^3.0! !!CreakoutPadModel methodsFor: 'accessing'!rotation	^ (pads at: 1) angle! !!CreakoutPadModel methodsFor: 'accessing' stamp: 'StevenRemot 4/6/2017 18:20'!leftVectorFor: aPad	| angle |	angle := (self leftAngleFor: aPad) degreesToRadians.	^(angle cos)@(angle sin)! !!CreakoutPadModel methodsFor: 'accessing' stamp: 'StevenRemot 4/6/2017 17:55'!rightAngleFor: aPad	^(self centerAngleFor: aPad) + (self padWidth / 2.0)! !!CreakoutPadModel methodsFor: 'accessing' stamp: 'StevenRemot 4/7/2017 12:08'!aimingPositionFor: aBall	^self center 		+		(Point 			r: (self radius - (self thickness / 2.0) - aBall radius)			degrees: (self centerAngleFor: 1))! !!CreakoutPadModel methodsFor: 'accessing' stamp: 'StevenRemot 4/6/2017 17:47'!radius	^45! !!CreakoutPadModel methodsFor: 'updating' stamp: 'StevenRemot 4/16/2017 14:14'!updateRotationSpeed: milliseconds	| targetSpeed rotationForce |	targetSpeed := self maxRotationSpeed		* rotationDirection.	rotationForce := targetSpeed = 0		ifTrue: [ 2.0 ]		ifFalse: [ 1.0 ].	rotationSpeed := rotationSpeed		+			(milliseconds * rotationForce				* (targetSpeed - rotationSpeed) sign)		min: (rotationSpeed max: targetSpeed)		max: (rotationSpeed min: targetSpeed)! !!CreakoutPadModel methodsFor: 'updating' stamp: 'StevenRemot 4/16/2017 13:59'!update: milliseconds	self		updateRotationSpeed: milliseconds;		rotate:			milliseconds / 1000.0 * rotationSpeed! !!CreakoutPadModel methodsFor: 'initialization' stamp: 'StevenRemot 4/8/2017 14:24'!initPads	pads := Array new: self numberOfPads.	1 to: self numberOfPads do: [ :padNumber | 		pads			at: padNumber			put:				(CreakoutBrickModel new					angle: 0;					bounceFactor: 4.0;					color: self padColor;					width: self padWidth;					thickness: self thickness;					origin: self center;					radius: self radius) ]! !!CreakoutPadModel methodsFor: 'initialization' stamp: 'StevenRemot 4/16/2017 13:57'!initialize	rotationDirection := 0.	rotationSpeed := 0.	self initPads;		rotation: 0.! !!CreakoutPadModel methodsFor: 'testing' stamp: 'StevenRemot 4/7/2017 19:51'!collidesWithBall: aBall	| bounceVector |	self doPads: [  :aPad |		bounceVector := aPad collisionVectorWith: aBall.		bounceVector ifNotNil: [ ^ bounceVector ] ].	^nil! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CreakoutPadModel class	instanceVariableNames: ''!!CreakoutPadModel class methodsFor: 'instance creation' stamp: 'StevenRemot 4/7/2017 19:47'!center: aPoint	^ self basicNew		center: aPoint;		initialize.! !!CreakoutPadModel class methodsFor: 'instance creation' stamp: 'StevenRemot 4/7/2017 19:41'!new	self error: 'You should create new instances of this class with center:'! !CreakoutBrickModel subclass: #CreakoutTargetBrickModel	instanceVariableNames: 'life deadBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'Creakout'!!CreakoutTargetBrickModel commentStamp: 'StevenRemot 4/8/2017 13:56' prior: 0!I am a brick that can be broken by a ball!!CreakoutTargetBrickModel methodsFor: 'damage handling' stamp: 'StevenRemot 4/8/2017 14:03'!ifDead: aBlock	(self life = 0) ifTrue: aBlock! !!CreakoutTargetBrickModel methodsFor: 'damage handling' stamp: 'StevenRemot 4/8/2017 14:02'!hit	^ life := (life - 1) max: 0! !!CreakoutTargetBrickModel methodsFor: 'accessing'!life	^ life! !!CreakoutTargetBrickModel methodsFor: 'accessing' stamp: 'StevenRemot 4/8/2017 14:54'!shrinkSpeed	"degrees / sec"	^ 100.0! !!CreakoutTargetBrickModel methodsFor: 'accessing' stamp: 'StevenRemot 4/8/2017 13:58'!life: aLife	life := aLife! !!CreakoutTargetBrickModel methodsFor: 'accessing' stamp: 'StevenRemot 4/8/2017 14:54'!onDead: aBlock	deadBlock := aBlock! !!CreakoutTargetBrickModel methodsFor: 'accessing'!targetWidth	^ life * self widthByLife! !!CreakoutTargetBrickModel methodsFor: 'accessing'!widthByLife	^ 20.0! !!CreakoutTargetBrickModel methodsFor: 'initialization'!initWidth	self width: self targetWidth! !!CreakoutTargetBrickModel methodsFor: 'updating' stamp: 'StevenRemot 4/8/2017 14:56'!update: milliseconds	self width > self targetWidth		ifTrue: [ self				width: (self width - (self shrinkSpeed * milliseconds / 1000.0) max: self targetWidth) ].				(self width = 0) ifTrue: [ deadBlock value: self ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CreakoutTargetBrickModel class	instanceVariableNames: ''!!CreakoutTargetBrickModel class methodsFor: 'accessing'!defaultBounceFactor	^ 1.0! !!CreakoutTargetBrickModel class methodsFor: 'accessing'!defaultThickness	^ 3.0! !!CreakoutTargetBrickModel class methodsFor: 'color'!randomColor	^ Color h: 360 atRandom s: 0.6 v: 1.0! !!CreakoutTargetBrickModel class methodsFor: 'instance creation' stamp: 'StevenRemot 4/8/2017 14:56'!radius: aRadius origin: aPoint angle: anAngle life: aLife onDead: aBlock	^ self new		radius: aRadius;		thickness: self defaultThickness;		origin: aPoint;		angle: anAngle;		color: self randomColor;		bounceFactor: self defaultBounceFactor;		life: aLife;		onDead: aBlock;		initWidth.! !!CreakoutTargetBrickModel class methodsFor: 'instance creation' stamp: 'StevenRemot 4/8/2017 14:51'!radius: aRadius origin: aPoint angle: anAngle life: aLife	^ self new		radius: aRadius;		thickness: self defaultThickness;		origin: aPoint;		angle: anAngle;		color: self randomColor;		bounceFactor: self defaultBounceFactor;		life: aLife;		initWidth.! !